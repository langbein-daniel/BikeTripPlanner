version: '3.9'
# https://docs.docker.com/compose/compose-file/#name-top-level-element
name: ${NAME}
services:

  #
  # BACKGROUND MAP
  #

  tilemaker:
    build:
      # Build a Docker image containing the `tilemaker` command.
      #
      # Using `FROM <git-url> as <name>` inside the Dockerfile of the tileserver-gl service below is not (yet) possible.
      # Thus, we build the image separately.
      #
      # https://docs.docker.com/engine/reference/commandline/build/#build-with-url
      context: github.com/systemed/tilemaker
    profiles: ['tilemaker']

  tileserver-gl:
    build:
      context: tileserver-gl
      args:
        # Name of the built `osm-excerpt` image.
        - NAME=${NAME}
        - MAP_STYLE_URL=${MAP_STYLE_URL}
        - MIN_LON=${MIN_LON}
        - MAX_LON=${MAX_LON}
        - MIN_LAT=${MIN_LAT}
        - MAX_LAT=${MAX_LAT}
    restart: unless-stopped
    ports:
      - '7070:8080/tcp'
    environment:
      VIRTUAL_HOST: "tileserver-gl.localhost"
      SELF_SIGNED_HOST: "tileserver-gl.localhost"

  #
  # ROUTING
  #

  opentripplanner:
    build:
      context: opentripplanner
      args:
        - BUILD_NAME=${BUILD_NAME}
        - JAVA_BUILD_OPTS=${JAVA_BUILD_OPTS}
        - JAVA_OPTS=${JAVA_OPTS}
    restart: unless-stopped
    ports:
      - '8080:8080/tcp'
    environment:
      - VIRTUAL_PORT=8080
      - VIRTUAL_HOST=opentripplanner.localhost
      - SELF_SIGNED_HOST=opentripplanner.localhost
    healthcheck:
      test: |
        curl --request POST --url 'http://localhost:8080/otp/routers/default/index/graphql' --header 'Content-Type: application/json' --header 'OTPTimeout: 1000' --data '{"query":"query agencies {agencies {name}}","operationName":"agencies"}' | grep '{"name":"VGN"}' || exit 1
      interval: ${HEALTHCHECK_INTERVAL}
      retries: 5
      start_period: 10s
      timeout: 5s

  #
  # GEOCODER
  #

  # https://github.com/pelias/api
  #
  # This is the core of Pelias. It talks to all other services (if available), Elasticsearch, and provides the interface for all queries to Pelias.
  # https://github.com/pelias/documentation/blob/master/services.md#descriptions
  api:
    build:
      context: ${PELIAS_BUILD_DIR}
      dockerfile: ./api.Dockerfile
      args:
        - PELIAS_API=${PELIAS_API}
    container_name: pelias_api
    restart: unless-stopped
    environment:
      - PORT=4000
      #
      - VIRTUAL_HOST=pelias.localhost
      - SELF_SIGNED_HOST=pelias.localhost
    ports: [ "0.0.0.0:4000:4000/tcp" ]
    depends_on:
      libpostal:
        condition: service_healthy
      placeholder:
        condition: service_healthy
      interpolation:
        condition: service_healthy
      pip:
        condition: service_healthy
      elasticsearch:
        condition: service_healthy
    # We imported data into two custom layers, stop and station.
    # If these layers don't exist, something is wrong!
    # http://localhost:4000/v1/search?text=n%C3%BCrnberg&lang=en&layers=stop,station
    healthcheck:
      test: curl --fail 'http://localhost:4000/v1/search?text=n%C3%BCrnberg&lang=en&layers=stop,station' | grep '"name":"Nürnberg Hbf"' || exit 1
      interval: ${HEALTHCHECK_INTERVAL}
      retries: 5
      start_period: 10s
      timeout: 5s

  # https://github.com/pelias/libpostal-service
  #
  # Libpostal is a library that provides an address parser using a statistical natural language processing model trained on OpenStreetMap, OpenAddresses, and other open data. It is quite good at parsing fully specified input, but cannot handle autocomplete very well.
  # https://github.com/pelias/documentation/blob/master/services.md#descriptions
  #
  # GIF demonstration on parsing a full address input: https://github.com/openvenues/libpostal#examples-of-parsing
  libpostal:
    image: ${PELIAS_LIBPOSTAL}
    container_name: pelias_libpostal
    restart: unless-stopped
    ports: [ "127.0.0.1:4400:4400" ]
    healthcheck:
      test: curl --fail 'http://localhost:4400/parse?address=Bahnhofsplatz%209,%2090443%20N%C3%BCrnberg,%20Germany' | grep '"label":"city","value":"nürnberg"' || exit 1
      interval: ${HEALTHCHECK_INTERVAL}
      retries: 5
      start_period: 10s
      timeout: 5s

  # https://github.com/pelias/placeholder
  #
  # Placeholder is used specifically to handle the relational component of geocoding. Placeholder understands, for example, that Paris is a city in a country called France, but that there is another city called Paris in the state of Texas, USA.
  # Placeholder also stores the translations of administrative areas in multiple languages. Therefore, it is required if any support for multiple languages is desired.
  # https://github.com/pelias/documentation/blob/master/services.md#descriptions
  #
  # Configuration: `PLACEHOLDER_DATA` - Path to the directory where the placeholder service will find the `store.sqlite3` database file.
  # https://github.com/pelias/placeholder#configuration-via-environment-variables
  placeholder:
    build:
      context: ${PELIAS_BUILD_DIR}
      dockerfile: ./placeholder.Dockerfile
      args:
        - PELIAS_PLACEHOLDER=${PELIAS_PLACEHOLDER}
    container_name: pelias_placeholder
    restart: unless-stopped
    environment: [ "PORT=4100" ]
    ports: [ "127.0.0.1:4100:4100" ]
    # Possible healthcheck URLs:
    #   http://localhost:4100/parser/search?text=n%C3%BCrnberg
    #   http://localhost:4100/parser/findbyid?ids=101905935
    #   http://localhost:4100/parser/query?text=n%C3%BCrnberg
    #   http://localhost:4100/parser/tokenize?text=n%C3%BCrnberg
    #   http://localhost:4100/parser/search?text=nürnberg&lang=rus
    healthcheck:
      test: curl --fail 'http://localhost:4100/parser/search?text=n%C3%BCrnberg' | grep '"name":"Nürnberg"' || exit 1
      interval: ${HEALTHCHECK_INTERVAL}
      retries: 5
      start_period: 10s
      timeout: 5s

  # https://github.com/pelias/interpolation
  #
  # The interpolation service combines street geometries with known addresses and address ranges, to allow estimating the position of addresses that might exist, but aren't in existing open data sources.
  # https://github.com/pelias/documentation/blob/master/services.md#descriptions
  #
  # CMD [ "./interpolate", "server", "/data/interpolation/address.db", "/data/interpolation/street.db" ]
  # https://github.com/pelias/interpolation/blob/a1451e9ba4db4ceabd53018310ab700cbc39708f/Dockerfile#L62
  #
  # The data is split into 2 different sqlite3 databases: street.db and address.db
  # https://github.com/pelias/interpolation#architecture
  interpolation:
    build:
      context: ${PELIAS_BUILD_DIR}
      dockerfile: ./interpolation.Dockerfile
      args:
        - PELIAS_INTERPOLATION=${PELIAS_INTERPOLATION}
    container_name: pelias_interpolation
    restart: unless-stopped
    environment: [ "PORT=4300" ]
    ports: [ "127.0.0.1:4300:4300" ]
    healthcheck:
      test: curl --fail 'localhost:4300/search/geojson?lat=49.44627&lon=11.08221=11&number=9&street=bahnhofsplatz' | grep '"type":"exact"' || exit 1
      interval: ${HEALTHCHECK_INTERVAL}
      retries: 5
      start_period: 10s
      timeout: 5s

  # https://github.com/pelias/pip-service
  #
  # The Point-in-Polygon (PIP) service loads polygon data representing the boundaries of cities, states, regions, countries etc. into memory, and can perform calculations on that geometric data. It's used to determine if a given point lies in a particular polygon. Thus, it's highly recommended for reverse geocoding.
  # https://github.com/pelias/documentation/blob/master/services.md#descriptions
  #
  # It will look for Who's on First data in the place configured in `pelias.json`.
  # https://github.com/pelias/pip-service#usage
  pip:
    build:
      context: ${PELIAS_BUILD_DIR}
      dockerfile: ./pip.Dockerfile
      args:
        - PELIAS_PIP=${PELIAS_PIP}
    container_name: pelias_pip-service
    restart: unless-stopped
    environment: [ "PORT=4200" ]
    ports: [ "127.0.0.1:4200:4200" ]
    healthcheck:
      test: curl --fail 'http://localhost:4200/11.08245/49.44511' | grep 'Nürnberg' || exit 1
      interval: ${HEALTHCHECK_INTERVAL}
      retries: 5
      start_period: 10s
      timeout: 5s

  # The underlying datastore that does most of the query heavy-lifting and powers our search results. We use Elasticsearch. Currently, versions 6 and 7 are supported.
  # https://github.com/pelias/pelias/#database
  elasticsearch:
    build:
      context: ${PELIAS_BUILD_DIR}
      dockerfile: ./elasticsearch.Dockerfile
      args:
        - PELIAS_ELASTICSEARCH=${PELIAS_ELASTICSEARCH}
    container_name: pelias_elasticsearch
    restart: unless-stopped
    ports: [ "127.0.0.1:9200:9200", "127.0.0.1:9300:9300" ]
    ulimits:
      memlock:
        soft: -1
        hard: -1
      nofile:
        soft: 65536
        hard: 65536
    cap_add: [ "IPC_LOCK" ]
    security_opt:
      - seccomp=unconfined
    healthcheck:
      # https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-health.html#cluster-health-api-desc
      test: curl --fail 'http://localhost:9200/_cluster/health?wait_for_status=green&timeout=1s' | grep '"timed_out":false' || exit 1
      interval: ${HEALTHCHECK_INTERVAL}
      retries: 5
      start_period: 20s
      timeout: 5s

  #
  # WEB UI
  #

  digitransit-ui:
    build:
      # https://docs.docker.com/engine/reference/commandline/build/#build-with-url
      context: github.com/langbein-daniel/digitransit-ui
    environment:
      - CONFIG=btp
      # Both, the client (user through its webbrowser) and the server (digitransit-ui) connect to these URLs.
      # The client can't resolve the internal docker hostnames `opentripplanner`, `api` and `tileserver-gl`.
      # The server can't resolve e.g. opentripplanner at localhost:8080.
      - OTP_URL=https://opentripplanner.localhost/otp/routers/default/
      - GEOCODING_BASE_URL=https://pelias.localhost/v1
      - DEFAULT_MAP_URL=https://tileserver-gl.localhost/styles/bicycle/
      #
      - VIRTUAL_HOST=digitransit.localhost
      - SELF_SIGNED_HOST=digitransit.localhost
    ports:
      - '9090:8080/tcp'
    depends_on:
      tileserver-gl:
        condition: service_healthy
      api:
        condition: service_healthy
      opentripplanner:
        condition: service_healthy

  #
  # REVERSE PROXY & CERTIFICATES
  #

  proxy:
    container_name: proxy  # Required by proxy-companion to reload this container
    image: nginxproxy/nginx-proxy
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/tmp/docker.sock:ro
      - ./private/certs:/etc/nginx/certs:ro

  proxy-companion:
    image: sebastienheyd/self-signed-proxy-companion
    restart: unless-stopped
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./private/certs:/etc/nginx/certs:rw
